use rand::{prelude::Distribution, distributions::Standard, Rng};
use serde::{Deserialize, Serialize};
use core::fmt;
use std::{fs, path::Path, collections::HashMap};
use crate::{models::planet::PlanetTrait, constants::PRINT_DEBUG};

use super::{planet::Planet, resource::{Resource, generate_resources, ResourceType}, player::Player};

#[derive(Serialize, Deserialize)]
struct Quote {
    personality: String,
    danger_level: String,
    quote: String,
}
#[derive(Serialize, Deserialize, Debug)]
pub enum TraderPersonality {
    Friendly,
    Neutral,
    Aggressive,
}
impl Distribution<TraderPersonality> for Standard {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> TraderPersonality {
        match rng.gen_range(0..3) {
            0 => TraderPersonality::Friendly,
            1 => TraderPersonality::Aggressive,
            _ => TraderPersonality::Neutral,
        }
    }
}
#[derive(Serialize, Deserialize, Debug)]
pub struct Trader {
    personality: TraderPersonality,
    pub resources: Vec<Resource>,
    pub credits: f32
}
impl fmt::Display for TraderPersonality {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            TraderPersonality::Friendly => write!(f, "Friendly"),
            TraderPersonality::Neutral => write!(f, "Neutral"),
            TraderPersonality::Aggressive => write!(f, "Aggressive"),
        }
    }
}


impl Trader {
    pub fn get_opening_line(&self,  planet: &Planet) -> String {

        let data_path = Path::new("data").join("quotes").join("trader").join("TraderDangerHello.json");
        println!("{}", data_path.display());

        let data = match fs::read_to_string(data_path) {
            Ok(content) => content,
            Err(e) => {
                eprintln!("Error reading file: {}", e);
                std::process::exit(1);
            }
        };
        let quotes: Vec<Quote> = serde_json::from_str(&data).unwrap();

        let danger_level = planet.get_danger();

        for quote in quotes {
            if quote.personality == self.personality.to_string()
                && quote.danger_level == danger_level.to_string()
            {
                return quote.quote.clone();
            }
        }
        "Quote not found".to_string()
    }

    // Creates a new instance of Trader with the given personality and resources
    pub fn new(personality: TraderPersonality, resources: Vec<Resource>) -> Self {
        // Initializes a new trader with the given personality and resources generated by calling generate_resources() and 1000 credits
        Trader { personality, resources: generate_resources(), credits: 1000.0 }
    }

    // Sells a resource from the player to the trader
    pub fn sell_resource(&mut self, resource_type: ResourceType, quantity: u32, player: &mut Player) -> Result<(), String> {
        // Check if the trader sells this type of resource
        if let Some(resource) = self.resources.iter().find(|r| r.resource_type == resource_type) {
            if let Some(sell_price) = resource.sell_price() {
                // Check if the player has this type of resource
                if let Some(player_quantity) = player.resources.get_mut(&resource_type) {
                    // Check if the player has enough quantity to sell
                    if *player_quantity >= quantity {
                        let cost = quantity as f32 * sell_price;
                        player.credits -= cost;
                        //self.personality.on_sell_successful(&resource_type);
                        //self.personality.on_buy_attempt(&resource_type);
                        *player_quantity -= quantity;
                        return Ok(());
                    } else {
                        return Err(format!("Player does not have enough of {:?} to sell.", resource_type));
                    }
                } else {
                    return Err(format!("Player does not have any {:?} to sell.", resource_type));
                }
            } else {
                // handle the case where sell_price is None
                return Err(format!("Trader does not sell {:?}.", resource_type));

            }
        } else {
            return Err(format!("Trader does not sell {:?}.", resource_type));
        }
    }
    pub fn buy_resource(&mut self, resource_type: ResourceType, quantity: u32, player: &mut Player) -> Result<(), String> {
        // Check if the trader buys this type of resource
        if let Some(resource) = self.resources.iter().find(|r| r.resource_type == resource_type) {
            if let Some(buy_price) = resource.buy_price() {
                // Check if the player has enough credits to buy
                let cost = quantity as f32 * buy_price;
                if player.credits >= cost {
                    player.credits -= cost;
                    //self.personality.on_buy_successful(&resource_type);
                    //self.personality.on_sell_attempt(&resource_type);
                    *player.resources.entry(resource_type).or_insert(0) += quantity;
                    return Ok(());
                } else {
                    return Err(format!("Player does not have enough credits to buy {:?}.", resource_type));
                }
            } else {
                // handle the case where buy_price is None
                return Err(format!("Trader does not buy {:?}.", resource_type));
            }
        } else {
            return Err(format!("Trader does not buy {:?}.", resource_type));
       }
    }

    //Traders can trade amongst themselved with the below (primary purpose is for testing trades)
    
// Sells a resource from the player to the trader
pub fn sell_resource_trader_to_trader(&mut self, resource_type: ResourceType, quantity: u32, trader: &mut Trader) -> Result<(), String> {
    // Check if the trader sells this type of resource
    if let Some(resource) = self.resources.iter().find(|r| r.resource_type == resource_type) {
        if let Some(sell_price) = resource.sell_price() {
            // Check if the player has this type of resource
            if let Some(player_resource) = trader.resources.iter_mut().find(|r| r.resource_type == resource_type) {
                // Check if the player has enough quantity to sell
                if player_resource.quantity >= Some(quantity) {
                    let cost = quantity as f32 * sell_price;
                    trader.credits -= cost;
                    //self.personality.on_sell_successful(&resource_type);
                    //self.personality.on_buy_attempt(&resource_type);
                    let mut player_quantity = player_resource.quantity.unwrap();
                    player_quantity -= quantity;
                    player_resource.quantity = Some(player_quantity);
                    self.credits += cost; // add earnings to player's credits
                    if PRINT_DEBUG {
                        println!("Successfully sold {:?} {:?} to trader. Player's credits: {:?}. Trader's credits: {:?}.", quantity, resource_type, self.credits, trader.credits);
                    }
                    return Ok(());
                } else {
                    if PRINT_DEBUG {
                        println!("Player does not have enough of {:?} to sell to trader. Available quantity: {:?}.", resource_type, player_resource.quantity);
                    }
                    return Err(format!("Player does not have enough of {:?} to sell.", resource_type));
                }
            } else {
                if PRINT_DEBUG {
                    println!("Player does not have any {:?} to sell to trader.", resource_type);
                }
                return Err(format!("Player does not have any {:?} to sell.", resource_type));
            }
        } else {
            // handle the case where sell_price is None
            if PRINT_DEBUG {
                println!("Trader does not sell {:?}.", resource_type);
            }
            return Err(format!("Trader does not sell {:?}.", resource_type));
        }
    } else {
        if PRINT_DEBUG {
            println!("Trader does not sell {:?}.", resource_type);
        }
        return Err(format!("Trader does not sell {:?}.", resource_type));
    }
}
    pub fn buy_resource_trader_to_trader(&mut self, resource_type: ResourceType, quantity: u32, trader: &mut Trader) -> Result<(), String> {
        // Check if the trader buys this type of resource
        if let Some(resource) = self.resources.iter().find(|r| r.resource_type == resource_type) {
            if let Some(buy_price) = resource.buy_price() {
                // Check if the player has enough credits to buy
                let cost = quantity as f32 * buy_price;
                if trader.credits >= cost {
                    trader.credits -= cost;
                    //self.personality.on_buy_successful(&resource_type);
                    //self.personality.on_sell_attempt(&resource_type);
                    if let Some(player_resource) = trader.resources.iter_mut().find(|r| r.resource_type == resource_type) {
                        let mut player_quantity = player_resource.quantity.unwrap();
                        player_quantity += quantity;
                        player_resource.quantity = Some(player_quantity);
                    } else {
                        return Err(format!("Player does not have any {:?} to buy.", resource_type));
                    }
                    return Ok(());
                } else {
                    return Err(format!("Player does not have enough credits to buy {:?}.", resource_type));
                }
            } else {
                // handle the case where buy_price is None
                return Err(format!("Trader does not buy {:?}.", resource_type));
            }
        } else {
            return Err(format!("Trader does not buy {:?}.", resource_type));
        }
    }


}
